{"ast":null,"code":"import { HttpHeaders } from '@angular/common/http';\nimport { catchError, map, tap, throwError } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport class GeneralApiService {\n  constructor(http) {\n    this.http = http;\n    this.userUrl = 'api/users';\n    this.bloodPressureUrl = 'api/userBloodPressureData';\n  }\n  login(user) {\n    const headers = new HttpHeaders({\n      'Content-Type': 'application/json'\n    });\n    //due to the limitation of in memory mock api call, in real life I would not return all the users,\n    //but here I will filter out the correct user\n    //in real life I will post the user email and password to backend,\n    //but please understand this is just a mock api call, angular in memory web api does not support all operations\n    return this.http.get(this.userUrl, {\n      headers\n    }).pipe(map(data => data.filter(each => each.email === user.email && each.password === user.password)), tap(data => console.log(JSON.stringify(data))), catchError(this.handleError));\n  }\n  //since the in memory mockup api is fake backend, so here need to mockup random number generator.\n  fakeMockupGenerateBloodPressure() {\n    let randomPressure = [];\n    for (let i = 0; i < 200; i++) {\n      //generate 200 random blood pressure to datebase\n      randomPressure.push(Math.floor(Math.random() * 100) + 80); //from 80 to 180\n    }\n\n    return randomPressure;\n  }\n  //due to the limitation of in memory mock api call, only query can be pass back\n  //by default is it's path value, it will account as Id.\n  //in real life I will GET /users/{token}\n  //but please understand this is just a mock api call, angular in memory web api does not support all operations\n  getUserBloodPressure(token) {\n    const headers = new HttpHeaders({\n      'Content-Type': 'application/json'\n    });\n    const url = `${this.bloodPressureUrl}?token=${token}`;\n    return this.http.get(url, {\n      headers\n    }).pipe(tap(data => console.log(JSON.stringify(data))), tap(data => data[0].bloodPressure = this.fakeMockupGenerateBloodPressure()), catchError(this.handleError));\n  }\n  handleError(err) {\n    // in a real world app, we may send the server to some remote logging infrastructure\n    // instead of just logging it to the console\n    let errorMessage;\n    if (err.error instanceof ErrorEvent) {\n      // A client-side or network error occurred. Handle it accordingly.\n      errorMessage = `An error occurred: ${err.error.message}`;\n    } else {\n      // The backend returned an unsuccessful response code.\n      // The response body may contain clues as to what went wrong,\n      errorMessage = `Backend returned code ${err.status}: ${err.body.error}`;\n    }\n    console.error(err);\n    return throwError(errorMessage);\n  }\n}\nGeneralApiService.ɵfac = function GeneralApiService_Factory(t) {\n  return new (t || GeneralApiService)(i0.ɵɵinject(i1.HttpClient));\n};\nGeneralApiService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: GeneralApiService,\n  factory: GeneralApiService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"AAAA,SAAqBA,WAAW,QAAQ,sBAAsB;AAG9D,SAAqBC,UAAU,EAASC,GAAG,EAAEC,GAAG,EAAEC,UAAU,QAAQ,MAAM;;;AAM1E,OAAM,MAAOC,iBAAiB;EAM5BC,YAAoBC,IAAgB;IAAhB,SAAI,GAAJA,IAAI;IAJhB,YAAO,GAAG,WAAW;IACrB,qBAAgB,GAAG,2BAA2B;EAGd;EAExCC,KAAK,CAACC,IAAU;IACd,MAAMC,OAAO,GAAG,IAAIV,WAAW,CAAC;MAAE,cAAc,EAAE;IAAkB,CAAE,CAAC;IAEvE;IACA;IACA;IACA;IACA,OAAO,IAAI,CAACO,IAAI,CAACI,GAAG,CAAS,IAAI,CAACC,OAAO,EAAE;MAACF;IAAO,CAAC,CAAC,CACpDG,IAAI,CACHX,GAAG,CAACY,IAAI,IAAIA,IAAI,CAACC,MAAM,CAACC,IAAI,IAAIA,IAAI,CAACC,KAAK,KAAKR,IAAI,CAACQ,KAAK,IAAID,IAAI,CAACE,QAAQ,KAAKT,IAAI,CAACS,QAAQ,CAAC,CAAC,EAC9Ff,GAAG,CAACW,IAAI,IAAIK,OAAO,CAACC,GAAG,CAACC,IAAI,CAACC,SAAS,CAACR,IAAI,CAAC,CAAC,CAAC,EAC9Cb,UAAU,CAAC,IAAI,CAACsB,WAAW,CAAC,CAC7B;EACH;EAGA;EACAC,+BAA+B;IAC7B,IAAIC,cAAc,GAAG,EAAE;IACvB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,GAAG,EAAEA,CAAC,EAAE,EAAE;MAAC;MAC7BD,cAAc,CAACE,IAAI,CAACC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,EAAE,GAAG,GAAG,CAAC,GAAG,EAAE,CAAC,CAAC;;;IAE5D,OAAOL,cAAc;EACvB;EAEA;EACA;EACA;EACA;EACAM,oBAAoB,CAACC,KAAa;IAChC,MAAMtB,OAAO,GAAG,IAAIV,WAAW,CAAC;MAAE,cAAc,EAAE;IAAkB,CAAE,CAAC;IACvE,MAAMiC,GAAG,GAAG,GAAG,IAAI,CAACC,gBAAgB,UAAUF,KAAK,EAAE;IAErD,OAAO,IAAI,CAACzB,IAAI,CAACI,GAAG,CAAsBsB,GAAG,EAAE;MAACvB;IAAO,CAAC,CAAC,CACxDG,IAAI,CACHV,GAAG,CAACW,IAAI,IAAIK,OAAO,CAACC,GAAG,CAACC,IAAI,CAACC,SAAS,CAACR,IAAI,CAAC,CAAC,CAAC,EAC9CX,GAAG,CAACW,IAAI,IAAIA,IAAI,CAAC,CAAC,CAAC,CAACqB,aAAa,GAAG,IAAI,CAACX,+BAA+B,EAAE,CAAC,EAC3EvB,UAAU,CAAC,IAAI,CAACsB,WAAW,CAAC,CAC7B;EACH;EAEQA,WAAW,CAACa,GAAQ;IAC1B;IACA;IACA,IAAIC,YAAoB;IACxB,IAAID,GAAG,CAACE,KAAK,YAAYC,UAAU,EAAE;MACnC;MACAF,YAAY,GAAG,sBAAsBD,GAAG,CAACE,KAAK,CAACE,OAAO,EAAE;KACzD,MAAM;MACL;MACA;MACAH,YAAY,GAAG,yBAAyBD,GAAG,CAACK,MAAM,KAAKL,GAAG,CAACM,IAAI,CAACJ,KAAK,EAAE;;IAEzEnB,OAAO,CAACmB,KAAK,CAACF,GAAG,CAAC;IAClB,OAAOhC,UAAU,CAACiC,YAAY,CAAC;EACjC;;AA/DWhC,iBAAiB;mBAAjBA,iBAAiB;AAAA;AAAjBA,iBAAiB;SAAjBA,iBAAiB;EAAAsC,SAAjBtC,iBAAiB;EAAAuC,YAFhB;AAAM","names":["HttpHeaders","catchError","map","tap","throwError","GeneralApiService","constructor","http","login","user","headers","get","userUrl","pipe","data","filter","each","email","password","console","log","JSON","stringify","handleError","fakeMockupGenerateBloodPressure","randomPressure","i","push","Math","floor","random","getUserBloodPressure","token","url","bloodPressureUrl","bloodPressure","err","errorMessage","error","ErrorEvent","message","status","body","factory","providedIn"],"sourceRoot":"","sources":["D:\\practise\\ClinicalDataApp\\my-clinical-data-app\\src\\app\\general-api.service.ts"],"sourcesContent":["import { HttpClient, HttpHeaders } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { User } from './model/user';\nimport { Observable, catchError, first, map, tap, throwError } from 'rxjs';\nimport { UserBloodPressure } from './model/user-blood-pressure';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class GeneralApiService {\n\n  private userUrl = 'api/users';\n  private bloodPressureUrl = 'api/userBloodPressureData';\n\n\n  constructor(private http: HttpClient) { }\n\n  login(user: User) : Observable<User[]> {\n    const headers = new HttpHeaders({ 'Content-Type': 'application/json' });\n\n    //due to the limitation of in memory mock api call, in real life I would not return all the users,\n    //but here I will filter out the correct user\n    //in real life I will post the user email and password to backend,\n    //but please understand this is just a mock api call, angular in memory web api does not support all operations\n    return this.http.get<User[]>(this.userUrl, {headers})\n    .pipe(\n      map(data => data.filter(each => each.email === user.email && each.password === user.password)),\n      tap(data => console.log(JSON.stringify(data))),\n      catchError(this.handleError)\n    );\n  }\n\n\n  //since the in memory mockup api is fake backend, so here need to mockup random number generator.\n  fakeMockupGenerateBloodPressure(): number[] {\n    let randomPressure = [];\n    for (let i = 0; i < 200; i++) {//generate 200 random blood pressure to datebase\n      randomPressure.push(Math.floor(Math.random() * 100) + 80);//from 80 to 180\n    }\n    return randomPressure;\n  }\n\n  //due to the limitation of in memory mock api call, only query can be pass back\n  //by default is it's path value, it will account as Id.\n  //in real life I will GET /users/{token}\n  //but please understand this is just a mock api call, angular in memory web api does not support all operations\n  getUserBloodPressure(token: string): Observable<UserBloodPressure[]> {\n    const headers = new HttpHeaders({ 'Content-Type': 'application/json' });\n    const url = `${this.bloodPressureUrl}?token=${token}`;\n\n    return this.http.get<UserBloodPressure[]>(url, {headers})\n    .pipe(\n      tap(data => console.log(JSON.stringify(data))),\n      tap(data => data[0].bloodPressure = this.fakeMockupGenerateBloodPressure()),\n      catchError(this.handleError)\n    )\n  }\n\n  private handleError(err: any) {\n    // in a real world app, we may send the server to some remote logging infrastructure\n    // instead of just logging it to the console\n    let errorMessage: string;\n    if (err.error instanceof ErrorEvent) {\n      // A client-side or network error occurred. Handle it accordingly.\n      errorMessage = `An error occurred: ${err.error.message}`;\n    } else {\n      // The backend returned an unsuccessful response code.\n      // The response body may contain clues as to what went wrong,\n      errorMessage = `Backend returned code ${err.status}: ${err.body.error}`;\n    }\n    console.error(err);\n    return throwError(errorMessage);\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}